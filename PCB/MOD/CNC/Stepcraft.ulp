#usage "<b>Stepcraft gcode exporter tool version 0.1</b>\n"
	 "<p>"
	"This ULP can convert EagleCAD Board Elements, Wires, Holes, Drills and Via's into RS-274 compliant g-code for pcb fabrication using a CNC Mill."
	"<p>"
	"See ---tutorial page--- for detailed usage."
	"<p>"
	"For Milling, draw wires on Layer 46 with the width of your end mill, these are your toolpaths."
	"<p>"
	"For Board Cutout, draw the outline of the board on Layer 20. The toolpath will follow the center of the line drawn, so for exact dimensions, offset the wire by the radius of the bit (0.0156in)."
	"<p>"
	"For Drills, it will output milling toolpaths for Holes, Vias, and Pads. All drills will be milled to diameter, if the drill diameter is smaller than the bit diameter, it will not be processed."
	"<p>"
	"Milling creates seperate text files for each bit diameter used (1/100, 1/64, 1/32, 1/16), Drilling and Dimension use a 1/32 endmill."
	"<p>"
	"<author>Author: Kina Smith</author><br>"
	"<br>"
	"Known issues:<ul>"
	"<li>Starting a wire with an arc is not currently supported. It will cut a line from start point to end point"
	"<li>All toolpaths are centered on the Wire they are generated from. This is an issue with the Dimension layer."
	"</ul>"

string Version = "0.1";  // Version 0.1 September 2015

/*
 * CHANGELOG================================================
 *  
 * 0.1 (08.03.2008): Initial version    
 *
 */  
// Definitions:
string fileMessage;

//Dialog Variables
int result = 0; // Dialog result
string str; // Temporary string

//Enable Outputs
int mill = 1;
int drill = 1;
int dimension = 1;

//Hole Options
int holes = 1;
int pads = 1;
int vias = 1;

real pcb_thickness = 1.85;
real milling_depth = 0.16;
int mill_layer = 16;
int dim_layer = 20;

//Bit Options
int spindle_speed_100 = 12000;
real max_depth_cut_100 = -0.05;
int plunge_feed_100 = 12;
int cut_feed_100 = 144;
int spindle_speed_64 = 12000;
real max_depth_cut_64 = -0.05;
int plunge_feed_64 = 12;
int cut_feed_64 = 144;
int spindle_speed_32 = 12000;
real max_depth_cut_32 = -0.15;
int plunge_feed_32 = 30;
int cut_feed_32 = 360;
int spindle_speed_16 = 12000;
real max_depth_cut_16 = -0.15;
int plunge_feed_16 = 30;
int cut_feed_16 = 360;
real feed_height = 5; //feeds, mm/min
real z_height = 0;

int plunge_state = 0; //0 is up, 1 is down

//filenames
string mill_100 = "_mill_010.nc";
string mill_64 = "_mill_015.nc";
string mill_32 = "_mill_031.nc";
string mill_16 = "_mill_062.nc";
int header_100_written = 0;
int header_64_written = 0;
int header_32_written = 0;
int header_16_written = 0;

//global's for movement
real prev_x_end = 0.0;
real prev_y_end = 0.0;
real curr_pos_x = 0.0;
real curr_pos_y = 0.0; 
real curr_pos_z = 0.0;

void plunge(real z_h, int feed) 
{
	printf("G01 Z%.3f F%d\n", z_h, feed);
	plunge_state = 1;
}
void retract(real z_f_h) 
{
	printf("G00 Z%.3f\n", z_f_h);
	plunge_state = 0;
}
void cut(real x, real y, int feed) 
{ 
	//Cuts from current position, to next position
	//printf("G01 X%.3f Y%.3f F%d\n", x1, y1, cut_feed_64);
	printf("G01 X%.3fY%.3f F%d\n", x, y, feed);
}
void rapid(real x, real y)
{
	//rapid move to position
	printf("G00 X%.3fY%.3f\n", x, y); //rapid move
}
void writeFooter(string name) 
{
	//Writes footer only to files which had a header written to them (active files)
	if(header_100_written)
		output(filesetext(name, mill_100), "a") 
			printf("G00 Z%.3f\nM05\nG04 P4000\nG00 X0Y0\n", feed_height); //footer. Return to origin and power off spindle
	if(header_64_written)
		output(filesetext(name, mill_64), "a") 
			printf("G00 Z%.3f\nM05\nG04 P4000\nG00 X0Y0\n", feed_height); //footer. Return to origin and power off spindle
	if(header_32_written)		
		output(filesetext(name, mill_32), "a") 
			printf("G00 Z%.3f\nM05\nG04 P4000\nG00 X0Y0\n", feed_height); //footer. Return to origin and power off spindle
	if(header_16_written)
		output(filesetext(name, mill_16), "a") 
			printf("G00 Z%.3f\nM05\nG04 P4000\nG00 X0Y0\n", feed_height); //footer. Return to origin and power off spindle
}
string writeHeader(string name, real width)
{
	//writes Header AND chooses where to append the incoming G-Code
	string r;
	if(width <= 0.012) 
	{
		if(!header_100_written) 
		{
			output(filesetext(name, mill_100),"wt") 
			{
				//format placeholder: %[parameter][flags][width][.precision][length]type
				printf("(RS-274 Compatible G-code generated for UCCNC controller and Stepcraft 2 Mill)\n");
				printf("(Created by in EagleCAD with the stepcraft.ulp %s.)\n", Version); 
				printf("(File: \"%s\" created on: %s)\n", filename(name), t2string(time()));
				printf("(Use a 1/100inch Bit)\n\n");
				printf("G90 G94 G49\nG21\nG00 Z5\nG00 X0Y0\nS%d M03\nG04 P4000\n", spindle_speed_100); //header: set to metric, go to origin, power on spindle
			}
			header_100_written = 1;
		}
		r = mill_100;
	}
	if(width > 0.012 && width <= 0.018) 
	{
		if(!header_64_written)
		{
			output(filesetext(name, mill_64),"wt") 
			{
				//format placeholder: %[parameter][flags][width][.precision][length]type
				printf("(RS-274 Compatible G-code generated for UCCNC controller and Stepcraft 2 Mill)\n");
				printf("(Created by in EagleCAD with the stepcraft.ulp %s.)\n", Version); 
				printf("(File: \"%s\" created on: %s)\n", filename(name), t2string(time()));
				printf("(Use a 1/64inch Bit)\n\n");
				printf("G90 G94 G49\nG21\nG00 Z5\nG00 X0Y0\nS%d M03\nG04 P4000\n", spindle_speed_64); //header: set to metric, go to origin, power on spindle
			}
			header_64_written = 1;
		}
		r = mill_64;
	}
	if(width > 0.018 && width <= 0.035) 
	{
		if(!header_32_written) 
		{
			output(filesetext(name, mill_32),"wt") 
			{
				//format placeholder: %[parameter][flags][width][.precision][length]type
				printf("(RS-274 Compatible G-code generated for UCCNC controller and Stepcraft 2 Mill)\n");
				printf("(Created by in EagleCAD with the stepcraft.ulp %s.)\n", Version); 
				printf("(File: \"%s\" created on: %s)\n", filename(name), t2string(time()));
				printf("(Use a 1/32inch Bit)\n\n");
				printf("G90 G94 G49\nG21\nG00 Z5\nG00 X0Y0\nS%d M03\nG04 P4000\n", spindle_speed_32); //header: set to metric, go to origin, power on spindle
			}
			header_32_written = 1;
		}
		r = mill_32;
	}
	if(width > 0.035 && width <= 0.066) 
	{
		if(!header_16_written) 
		{
			output(filesetext(name, mill_16),"wt") 
			{
				//format placeholder: %[parameter][flags][width][.precision][length]type
				printf("(RS-274 Compatible G-code generated for UCCNC controller and Stepcraft 2 Mill)\n");
				printf("(Created by in EagleCAD with the stepcraft.ulp %s.)\n", Version); 
				printf("(File: \"%s\" created on: %s)\n", filename(name), t2string(time()));
				printf("(Use a 1/16inch Bit)\n\n");
				printf("G90 G94 G49\nG21\nG00 Z5\nG00 X0Y0\nS%d M03\nG04 P4000\n", spindle_speed_16); //header: set to metric, go to origin, power on spindle
			}
			header_16_written = 1;
		}
		r = mill_16;
	}
	return r;
}
void cutWire(real x_s, real y_s, real x_e, real y_e, int plunge_feed, int cut_feed) 
{
	real x_start = x_s;
	real y_start = y_s;
	real x_end = x_e;
	real y_end = y_e;
	if(prev_x_end != x_start || prev_y_end != y_start) 
	{
		//printf("(-->next line out of position. Retracting, and repositioning)\n");
		retract(feed_height); //retract to feed height
		rapid(x_start, y_start); //rapid move to start
		curr_pos_x = x_start;
		curr_pos_y = y_start;
		curr_pos_z = z_height;
	}
	if((curr_pos_x != x_start || curr_pos_y != y_start) && plunge_state == 0) 
	{ 
		//printf("(-->Moving to Position and cutting line)\n");
		rapid(x_start, y_start); //rapid move to start
		plunge(z_height, plunge_feed); //plunge to cut height
		cut(x_end, y_end, cut_feed);
		curr_pos_x = x_end;
		curr_pos_y = y_end;
		curr_pos_z = z_height;
	}
	if((curr_pos_x != x_start || curr_pos_y != y_start) && plunge_state == 1) 
	{ 
		//printf("(-->Retracting, Moving to position, Cutting Line)\n");
		retract(feed_height);
		rapid(x_start, y_start); //rapid to start
		plunge(z_height, plunge_feed);
		cut(x_end, y_end, cut_feed); //cut to this point
		curr_pos_x = x_end;
		curr_pos_y = y_end;
		curr_pos_z = z_height;
	}
	if(curr_pos_x == x_start && curr_pos_y == y_start && plunge_state == 1 && curr_pos_z == z_height) 
	{ 
		//printf("(-->Cutting Line)\n");
		cut(x_end, y_end, cut_feed);
		curr_pos_x = x_end;
		curr_pos_y = y_end;
		curr_pos_z = z_height;
	}
	if(curr_pos_x == x_start && curr_pos_y == y_start && plunge_state == 1 && curr_pos_z != z_height) 
	{
		//printf("(-->plunge, then cut\n)");
		plunge(z_height, plunge_feed);
		cut(x_end, y_end, cut_feed);
		curr_pos_x = x_end;
		curr_pos_y = y_end;
		curr_pos_z = z_height;	
	}
	if(curr_pos_x == x_start && curr_pos_y == y_start && plunge_state == 0)
	{ 
		//printf("(-->Plunging, then Cutting Line)\n");
		plunge(z_height, plunge_feed);
		cut(x_end, y_end, cut_feed);
		curr_pos_x = x_end;
		curr_pos_y = y_end;
		curr_pos_z = z_height;
	}
	prev_x_end = x_end;
	prev_y_end = y_end;
}
void cutArc(real x1, real y1, real x2, real y2, real xc, real yc, int plunge_feed, int cut_feed) 
{
	real arc_x1 = x1;
	real arc_y1 = y1;
	real arc_x2 = x2;
	real arc_y2 = y2;
	real arc_x_center = xc;
	real arc_y_center = yc;
	real arc_x_start = 0;
	real arc_y_start = 0;
	real arc_x_end = 0;
	real arc_y_end = 0;
	real radius = 0;
	int rot_dir = 0; //rotation direction. 0 is CCW, 1 is CW
	if(curr_pos_x == arc_x1 && curr_pos_y == arc_y1) 
	{
	 	arc_x_start = arc_x1;
	 	arc_y_start = arc_y1;
	 	arc_x_end = arc_x2;
	 	arc_y_end = arc_y2;
	 	radius = abs(arc_x_start - arc_x_end);
	 	rot_dir = 0;
	 	printf("G03\nX%.3fY%.3f R%.3f\n", arc_x_end, arc_y_end, radius);
		curr_pos_x = arc_x_end;
		curr_pos_y = arc_y_end;
	} else if(curr_pos_x == arc_x2 && curr_pos_y == arc_y2) 
	{
		arc_x_start = arc_x2; 
		arc_y_start = arc_y2; 
		arc_x_end = arc_x1;
		arc_y_end = arc_y1;
		radius = abs(arc_x_start - arc_x_end);
		rot_dir = 1;
		printf("G02\nX%.3fY%.3f R%.3f\n", arc_x_end, arc_y_end, radius);
		curr_pos_x = arc_x_end;
		curr_pos_y = arc_y_end;
	} else 
	{
		printf("(bad arc, cutting point to point)\n");
		retract(feed_height);
		rapid(arc_x1, arc_y1); //rapid move to start
		plunge(z_height, plunge_feed); //plunge to cut height
		cut(arc_x2, arc_y2, cut_feed);
		retract(feed_height);
	}
	prev_x_end = arc_x_end;
	prev_y_end = arc_y_end;
	// printf("(Arc: (%.3f, %.3f), (%.3f, %.3f), (%.3f, %.3f), %.3f, %.3f, %.3f, %d)\n", u2mm(W.arc.x1), u2mm(W.arc.y1), u2mm(W.arc.x2), u2mm(W.arc.y2), u2mm(W.arc.xc), u2mm(W.arc.yc), u2mm(W.width), W.arc.angle1, W.arc.angle2, rot_dir);
}
void cutHole(real c_x, real c_y, real d, int plunge_feed, int cut_feed) 
{
	//hole centers
	real center_x = c_x;
	real center_y = c_y;
	//hole radius
	real hole_radius = d/2;
	//cutter radius in mm
	real bit_radius = 0.79375/2; 
	//cut point start
	real x_start = center_x + (hole_radius-bit_radius);
	real y_start = center_y;
	//offsets to center.
	real i_offset = -(hole_radius - bit_radius);
	real j_offset = 0;

	if(i_offset >= 0) 
	{
		i_offset = 0; 
		printf("(-->HOLE IS TOO SMALL, I CAN'T CUT THAT!!)\n");
	}

	if((curr_pos_x != x_start || curr_pos_y != y_start) && plunge_state == 1) 
	{ 
		// printf("(retract, move to start, plunge, cut\n");
		retract(feed_height);
		rapid(x_start, y_start);
		plunge(z_height, plunge_feed);
		printf("G03 F%d\n", cut_feed); //init CCW arc
		printf("X%.3fY%.3f I%.3f\n", x_start, y_start, i_offset);
		curr_pos_x = x_start;
		curr_pos_y = y_start;
		curr_pos_z = z_height;
	}
	if(curr_pos_x == x_start && curr_pos_y == y_start && plunge_state == 1 && curr_pos_z != z_height) 
	{
		// printf("plunge, and cut\n");
		plunge(z_height, plunge_feed);
		printf("G03 F%d\n", cut_feed); //init CCW arc
		printf("X%.3fY%.3f I%.3f\n", x_start, y_start, i_offset);
		curr_pos_x = x_start;
		curr_pos_y = y_start;
		curr_pos_z = z_height;	
	}
	if((curr_pos_x != x_start || curr_pos_y != y_start) && plunge_state == 0) 
	{
		// printf("Cutter is Up: Move to start, plunge, and Cut\n");
		rapid(x_start, y_start);
		plunge(z_height, plunge_feed);
		printf("G03 F%d\n", cut_feed); //init CCW arc
		printf("X%.3fY%.3f I%.3f\n", x_start, y_start, i_offset);
		curr_pos_x = x_start;
		curr_pos_y = y_start;
		curr_pos_z = z_height;
	}
}
void Process_Mill() 
{
	int mill_cut_feed;
	int mill_plunge_feed;
	board(B) 
	{
		for(z_height = max_depth_cut_64; z_height >= -milling_depth; z_height += max_depth_cut_64)
		{
			B.wires(W) 
			{
				if(W.layer == mill_layer) 
				{
					output(filesetext(B.name, writeHeader(B.name, u2inch(W.width))), "a")
					{
						// printf("(Line: (%.3f, %.3f) (%.3f, %.3f), %.3f, %d)\n", u2mm(W.x1), u2mm(W.y1), u2mm(W.x2), u2mm(W.y2), u2inch(W.width), W.layer);
						if(u2inch(W.width) <= 0.012) 
						{
							mill_cut_feed = cut_feed_100; 
							mill_plunge_feed = plunge_feed_100;
						}
						if(u2inch(W.width) > 0.012 && u2inch(W.width) <= 0.016) 
						{
							mill_cut_feed = cut_feed_64; 
							mill_plunge_feed = plunge_feed_64;
						}
						if(u2inch(W.width) > 0.016 && u2inch(W.width) <= 0.032) 
						{
							mill_cut_feed = cut_feed_32; 
							mill_plunge_feed = plunge_feed_32;
						}
						if(u2inch(W.width) > 0.032 && u2inch(W.width) <= 0.066) 
						{
							 mill_cut_feed = cut_feed_16; 
							 mill_plunge_feed = plunge_feed_16;
						}
						if(!W.arc) //if it's a line
							cutWire(u2mm(W.x1), u2mm(W.y1), u2mm(W.x2), u2mm(W.y2), mill_plunge_feed, mill_cut_feed);
						if(W.arc) //if it's an arc
							cutArc(u2mm(W.arc.x1), u2mm(W.arc.y1), u2mm(W.arc.x2), u2mm(W.arc.y2), u2mm(W.arc.xc),  u2mm(W.arc.yc), mill_plunge_feed, mill_cut_feed);
					}
				}
			}
		}
		writeFooter(B.name);
	}
}
void Process_Dimension() 
{
	int mill_cut_feed = cut_feed_32;
	int mill_plunge_feed = plunge_feed_32;
	board(B)
	{
		output(filesetext(B.name, "_dimension.nc"),"wt") 
		{
			printf("(RS-274 Compatible G-code generated for UCCNC controller and Stepcraft 2 Mill)\n");
			printf("(Created by in EagleCAD with the stepcraft.ulp %s.)\n", Version); 
			printf("(File: \"%s\" created on: %s)\n", filename(B.name), t2string(time()));
			printf("(Use a 1/32inch Bit)\n\n");
			printf("G90 G94 G49\nG21\nG00 Z5\nG00 X0Y0\nS%d M03\nG04 P4000\n", spindle_speed_32); //header: set to metric, go to origin, power on spindle
			for(z_height = max_depth_cut_32; z_height >= -pcb_thickness; z_height += max_depth_cut_32)
			{
				B.wires(W) 
				{
					if(!W.arc && W.layer == dim_layer) 
						cutWire(u2mm(W.x1), u2mm(W.y1), u2mm(W.x2), u2mm(W.y2), mill_plunge_feed, mill_cut_feed);
					if(W.arc && W.layer == dim_layer) 
						cutArc(u2mm(W.arc.x1), u2mm(W.arc.y1), u2mm(W.arc.x2), u2mm(W.arc.y2), u2mm(W.arc.xc),  u2mm(W.arc.yc), mill_plunge_feed, mill_cut_feed);				}
				if((pcb_thickness -(-z_height)) < (-max_depth_cut_32)) 
				{
					z_height = -pcb_thickness;
					B.wires(W) 
					{
						if(!W.arc && W.layer == dim_layer) 
							cutWire(u2mm(W.x1), u2mm(W.y1), u2mm(W.x2), u2mm(W.y2), mill_plunge_feed, mill_cut_feed);
						if(W.arc && W.layer == dim_layer) 
							cutArc(u2mm(W.arc.x1), u2mm(W.arc.y1), u2mm(W.arc.x2), u2mm(W.arc.y2), u2mm(W.arc.xc),  u2mm(W.arc.yc), mill_plunge_feed, mill_cut_feed);
					}
				}
			}
			printf("G00 Z%.3f\nM05\nG04 P4000\nG00 X0Y0\n", feed_height); //footer. Return to origin and power off spindle
		}
	}
}
void Process_Drill() 
{
	int mill_cut_feed = cut_feed_32;
	int mill_plunge_feed = plunge_feed_32;
	board(B) 
	{
		output(filesetext(B.name, "_drill.nc"),"wt")
		{
			//Header
			printf("(RS-274 Compatible G-code generated for UCCNC controller and Stepcraft 2 Mill)\n");
			printf("(Created by in EagleCAD with the stepcraft.ulp %s.)\n", Version); 
			printf("(File: \"%s\" created on: %s)\n", filename(B.name), t2string(time()));
			printf("(Use a 1/32inch Bit)\n\n");
			printf("G90 G94 G49\nG21\nG00 Z5\nG00 X0Y0\nS%d M03\nG04 P4000\n", spindle_speed_32); //header: set to metric, go to origin, power on spindle
			if(holes)
			{
				B.holes(H) 
				{
					for(z_height = max_depth_cut_32; z_height >= -pcb_thickness; z_height += max_depth_cut_32)
					{
						cutHole(u2mm(H.x), u2mm(H.y), u2mm(H.drill), mill_plunge_feed, mill_cut_feed);
						if((pcb_thickness -(-z_height)) < (-max_depth_cut_32)) 
						{
							z_height = -pcb_thickness;
							cutHole(u2mm(H.x), u2mm(H.y), u2mm(H.drill), mill_plunge_feed, mill_cut_feed);
						}
					}
				}
			}
			if(pads)
			{
				B.elements(E) 
				{
					E.package.contacts(C) 
					{
						if (C.pad) 
						{
							for(z_height = max_depth_cut_32; z_height >= -pcb_thickness; z_height += max_depth_cut_32)
							{
								cutHole(u2mm(C.pad.x), u2mm(C.pad.y), u2mm(C.pad.drill), mill_plunge_feed, mill_cut_feed);
								if((pcb_thickness -(-z_height)) < (-max_depth_cut_32)) 
								{
									z_height = -pcb_thickness;
									cutHole(u2mm(C.pad.x), u2mm(C.pad.y), u2mm(C.pad.drill), mill_plunge_feed, mill_cut_feed);
								}
							}
						}
					}			
				}
			}
			if(vias)
			{
				B.signals(S) 
				{
					S.vias(V)
					{
						for(z_height = max_depth_cut_32; z_height >= -pcb_thickness; z_height += max_depth_cut_32)
						{
							cutHole(u2mm(V.x), u2mm(V.y), u2mm(V.drill), mill_plunge_feed, mill_cut_feed);
							if((pcb_thickness -(-z_height)) < (-max_depth_cut_32)) 
							{
								z_height = -pcb_thickness;
								cutHole(u2mm(V.x), u2mm(V.y), u2mm(V.drill), mill_plunge_feed, mill_cut_feed);
							}
						}
					}
				}
			}
			printf("G00 Z%.3f\nM05\nG04 P4000\nG00 X0Y0\n", feed_height); //footer. Return to origin and power off spindle
		}
	}
}

/* ------------- MAIN ROUTINE --------------- */
if (board) {
	result = dlgDialog("Generates g-code for Stepcraft mill") 
	{
		sprintf(str, "<qt><H3><P>Generate G-Code for Stepcraft 2 v%s</P></H3>"+
		"<P><B>By Kina Smith (kina@kinasmith.com)</B></P>"+
		"<HR><P>This ULP generates RS-274 compliant g-code " + 
		"for the Stepcraft CNC Mill from the Mill, Holes, and Dimension layers.</P></qt>", Version);
		dlgLabel(str);
		// Options
		dlgTabWidget 
		{
			dlgTabPage("Options") 
			{
				dlgVBoxLayout
				{
					dlgGroup("") 
					{
						dlgLabel("This will generate code using the default settings for Speeds, Feeds, and Stepdowns.");	
					}
					dlgHBoxLayout 
					{
						dlgStretch(1);
						dlgGroup("Outputs") 
						{
							dlgCheckBox("&Mill", mill);
							dlgCheckBox("&Drills", drill);
							dlgCheckBox("&Dimension", dimension);
						}
						dlgSpacing(20);
						dlgGridLayout 
						{
							dlgCell(0,0) dlgLabel("PCB Thickness(mm) ");
							dlgCell(0,1) dlgRealEdit(pcb_thickness,0,2);
							dlgCell(1,0) dlgLabel("Milling Depth (mm)");
							dlgCell(1,1) dlgRealEdit(milling_depth,0,1);
							dlgCell(2,0) dlgLabel("Mill Layer");
							dlgCell(2,1) dlgIntEdit(mill_layer,0,200);
							dlgCell(3,0) dlgLabel("Dimension Layer");
							dlgCell(3,1) dlgIntEdit(dim_layer,0,200);
						}
						dlgStretch(1);
					}
					dlgStretch(1);
				}
				dlgStretch(1);
			}
			dlgTabPage("Advanced") 
			{
				dlgHBoxLayout
				{
					dlgGroup("Feed+Speed Options") 
					{
						dlgTabWidget 
						{
							dlgTabPage("1/100")
							{
								dlgGridLayout 
								{
									dlgCell(0,0) dlgLabel("Spindle Speed(rpm) ");
									dlgCell(0,1) dlgIntEdit(spindle_speed_100,500,20000);
									dlgCell(1,0) dlgLabel("Plunge Rate (mm/min)");
									dlgCell(1,1) dlgIntEdit(plunge_feed_100,0,500);
									dlgCell(2,0) dlgLabel("Cut Feed Rate (mm/in)");
									dlgCell(2,1) dlgIntEdit(cut_feed_100,0,500);
									dlgCell(3,0) dlgLabel("Max Depth Cut (mm)");
									dlgCell(3,1) dlgRealEdit(max_depth_cut_100,-1.,0);
								}
							}
							dlgTabPage("1/64")
							{
								dlgGridLayout 
								{
									dlgCell(0,0) dlgLabel("Spindle Speed(rpm) ");
									dlgCell(0,1) dlgIntEdit(spindle_speed_64,500,20000);
									dlgCell(1,0) dlgLabel("Plunge Rate (mm/min)");
									dlgCell(1,1) dlgIntEdit(plunge_feed_64,0,500);
									dlgCell(2,0) dlgLabel("Cut Feed Rate (mm/in)");
									dlgCell(2,1) dlgIntEdit(cut_feed_64,0,500);
									dlgCell(3,0) dlgLabel("Max Depth Cut (mm)");
									dlgCell(3,1) dlgRealEdit(max_depth_cut_64,-1.,0);
								}
							}
							dlgTabPage("1/32") 
							{
								dlgGridLayout 
								{
									dlgCell(0,0) dlgLabel("Spindle Speed(rpm) ");
									dlgCell(0,1) dlgIntEdit(spindle_speed_32,500,20000);
									dlgCell(1,0) dlgLabel("Plunge Rate (mm/min)");
									dlgCell(1,1) dlgIntEdit(plunge_feed_32,0,500);
									dlgCell(2,0) dlgLabel("Cut Feed Rate (mm/in)");
									dlgCell(2,1) dlgIntEdit(cut_feed_32,0,500);
									dlgCell(3,0) dlgLabel("Max Depth Cut (mm)");
									dlgCell(3,1) dlgRealEdit(max_depth_cut_32,-1.,0);
								}
							}
							dlgTabPage("1/16")
							{
								dlgGridLayout 
								{
									dlgCell(0,0) dlgLabel("Spindle Speed(rpm) ");
									dlgCell(0,1) dlgIntEdit(spindle_speed_16,500,20000);
									dlgCell(1,0) dlgLabel("Plunge Rate (mm/min)");
									dlgCell(1,1) dlgIntEdit(plunge_feed_16,0,500);
									dlgCell(2,0) dlgLabel("Cut Feed Rate (mm/in)");
									dlgCell(2,1) dlgIntEdit(cut_feed_16,0,500);
									dlgCell(3,0) dlgLabel("Max Depth Cut (mm)");
									dlgCell(3,1) dlgRealEdit(max_depth_cut_16,-1.,0);
								}
							}
						}
					}
					dlgGroup("Drill Outputs") 
					{	
						dlgCheckBox("&Holes", holes);
						dlgCheckBox("&Vias", vias);
						dlgCheckBox("&Pads", pads);
					}
						
				}
			}
		}
		dlgHBoxLayout
		{
			dlgStretch(1);
			dlgPushButton("+Generate") dlgAccept();
			dlgPushButton("-Cancel") dlgReject();
			dlgStretch(1);
		}
		
	};
	if (!result) exit(0);    
	if(mill) Process_Mill();
	if(drill) Process_Drill();
	if(dimension) Process_Dimension();
} else {
	dlgMessageBox("<hr><b>ERROR: This ULP will only operate in the board layout view.</b></hr><p>Switch to the board layout editor and re-run.");
	exit(1);
}








//argv[] are the arguements in the run command

//cmd.renumber -> create window and display
//centroid screaming circuits -> create and save external file
//dose-pro -> creates files for solder dispensing machine
//ulpmessage -> makes popup message
//count.ulp -> generates dialog box w/ data

//    int sprintf(string result, string format[, argument, ...]);
